---
title: 347. Top K Frequent Elements (Medium)
tags:
  - Array
  - Hash Table
  - Divide and Conquer
  - Sorting
  - Heap (Priority Queue)
  - Bucket Sort
  - Counting
  - Quickselect
---

import SolutionDocHead from "../src/containers/SolutionDocHead";

<SolutionDocHead
  solutionType={"medium"}
  labels={[
    "Array",
    "Hash Table",
    "Divide and Conquer",
    "Sorting",
    "Heap (Priority Queue)",
    "Bucket Sort",
    "Counting",
    "Quickselect",
  ]}
  companies={["Yelp"]}
  url={"https://leetcode.com/problems/encode-and-decode-tinyurl/"}
/>

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in <b>any order</b>.

<b>Example 1:</b>

```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

<b>Example 2:</b>

```
Input: nums = [1], k = 1
Output: [1]
```

<b>Constraints:</b>

- 1 <= nums.length <= 10<sup>5</sup>
- `k` is in the range `[1, the number of unique elements in the array]`.
- It is <b>guaranteed</b> that the answer is <b>unique</b>.

Follow up: Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.

```ts title=solution.ts
function topKFrequent(nums: number[], k: number): number[] {
  const freqMap = new Map();
  const result = [];
  nums.forEach((n) => freqMap.set(n, (freqMap.get(n) || 0) + 1));
  const sortedArray = [...freqMap.entries()].sort((a, b) => b[1] - a[1]);
  for (let i = 0; i < k; i++) {
    result.push(sortedArray[i][0]);
  }
  return result;
}
```
