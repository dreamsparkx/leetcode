"use strict";(self.webpackChunkleetcode=self.webpackChunkleetcode||[]).push([[4770],{3722:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return u},default:function(){return c},frontMatter:function(){return l},metadata:function(){return m},toc:function(){return p}});var o=n(7462),r=n(3366),s=(n(7294),n(3905)),i=n(5714),a=["components"],l={title:"15. 3Sum (Medium)",tags:["Array","Two Pointers","Sorting"]},u=void 0,m={unversionedId:"15",id:"15",title:"15. 3Sum (Medium)",description:"<SolutionDocHead",source:"@site/solutions/15.mdx",sourceDirName:".",slug:"/15",permalink:"/leetcode/solutions/15",tags:[{label:"Array",permalink:"/leetcode/solutions/tags/array"},{label:"Two Pointers",permalink:"/leetcode/solutions/tags/two-pointers"},{label:"Sorting",permalink:"/leetcode/solutions/tags/sorting"}],version:"current",lastUpdatedBy:"Gaurav Bharti",lastUpdatedAt:1650482437,formattedLastUpdatedAt:"4/21/2022",frontMatter:{title:"15. 3Sum (Medium)",tags:["Array","Two Pointers","Sorting"]},sidebar:"solutions",previous:{title:"11. Container With Most Water (Medium)",permalink:"/leetcode/solutions/11"},next:{title:"19. Remove Nth Node From End of List (Medium)",permalink:"/leetcode/solutions/19"}},d={},p=[],h={toc:p};function c(e){var t=e.components,n=(0,r.Z)(e,a);return(0,s.kt)("wrapper",(0,o.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)(i.Z,{solutionType:"medium",labels:["Array","Two Pointers","Sorting"],url:"https://leetcode.com/problems/3sum/",mdxType:"SolutionDocHead"}),(0,s.kt)("p",null,"Given an integer array nums, return all the triplets ",(0,s.kt)("inlineCode",{parentName:"p"},"[nums[i], nums[j], nums[k]]")," such that ",(0,s.kt)("inlineCode",{parentName:"p"},"i != j"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"i != k"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"j != k"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"nums[i] + nums[j] + nums[k] == 0"),"."),(0,s.kt)("p",null,"Notice that the solution set must not contain duplicate triplets."),(0,s.kt)("b",null,"Example 1:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\n")),(0,s.kt)("b",null,"Example 2:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: nums = []\nOutput: []\n")),(0,s.kt)("b",null,"Example 3:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: nums = [0]\nOutput: []\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=solution.ts",title:"solution.ts"},"function threeSum(nums: number[]): number[][] {\n  const results = [];\n\n  // obviously irrelevant if we don't have at least 3 numbers to play with!\n  if (nums.length < 3) return results;\n\n  // having the numbers in ascending order will make this problem much easier.\n  // also, knowing the overall problem  will take at least O(N^2) time, we can\n  // afford the O(NlogN) sort operation\n  nums = nums.sort((a, b) => a - b);\n\n  // if the question asks us for a custom target, we can control it here\n  let target = 0;\n\n  for (let i = 0; i < nums.length - 2; i++) {\n    // `i` represents the \"left\" most number in our sorted set.\n    // once this number hits 0, there's no need to go further since\n    // positive numbers cannot sum to a negative number\n    if (nums[i] > target) break;\n\n    // we don't want repeats, so skip numbers we've already seen\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n\n    // `j` represents the \"middle\" element between `i` and `k`.\n    // we will increment this up through the array while `i` and `k`\n    // are anchored to their positions. we will decrement `k` for\n    // for each pass through the array, and finally increment `i`\n    // once `j` and `k` meet.\n    let j = i + 1;\n\n    // `k` represents the \"right\" most element\n    let k = nums.length - 1;\n\n    // to summarize our setup, we have `i` that starts at the beginning,\n    // `k` that starts at the end, and `j` that races in between the two.\n    //\n    // note that `i` is controlled by our outer for-loop and will move the slowest.\n    // in the meantime, `j` and `k` will take turns inching towards each other depending\n    // on some logic we'll set up below. once they collide, `i` will be incremented up\n    // and we'll repeat the process.\n\n    while (j < k) {\n      let sum = nums[i] + nums[j] + nums[k];\n\n      // if we find the target sum, increment `j` and decrement `k` for\n      // other potential combos where `i` is the anchor\n      if (sum === target) {\n        // store the valid threesum\n        results.push([nums[i], nums[j], nums[k]]);\n\n        // this is important! we need to continue to increment `j` and decrement `k`\n        // as long as those values are duplicated. in other words, we wanna skip values\n        // we've already seen. otherwise, an input array of [-2,0,0,2,2] would result in\n        // [[-2,0,2], [-2,0,2]].\n        //\n        // (i'm not a fan of this part because we're doing a while loop as we're\n        // already inside of another while loop...)\n        while (nums[j] === nums[j + 1]) j++;\n        while (nums[k] === nums[k - 1]) k--;\n\n        // finally, we need to actually move `j` forward and `k` backward to the\n        // next unique elements. the previous while loops will not handle this.\n        j++;\n        k--;\n\n        // if the sum is too small, increment `j` to get closer to the target\n      } else if (sum < target) {\n        j++;\n\n        // if the sum is too large, decrement `k` to get closer to the target\n      } else {\n        // (sum > target)\n        k--;\n      }\n    }\n  }\n\n  return results;\n}\n")))}c.isMDXComponent=!0}}]);