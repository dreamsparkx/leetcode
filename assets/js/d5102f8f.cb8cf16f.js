"use strict";(self.webpackChunkleetcode=self.webpackChunkleetcode||[]).push([[4434],{6529:function(e,n,t){var i=t(7294),a=t(1285),l=(0,t(1120).Z)((function(e){return{root:{display:"flex",flexWrap:"wrap","& > *":{margin:e.spacing(.5)}}}}));n.Z=function(e){var n=l(),t=e.labels;return i.createElement("div",{className:n.root},t.map((function(e,n){return i.createElement(a.Z,{label:e,key:n+"-"+e})})))}},5714:function(e,n,t){t.d(n,{Z:function(){return r}});var i=t(7294),a={medium:"medium_AtL5",easy:"easy_Arst",hard:"hard_vnPO"},l=function(e){var n=e.type,t="";switch(n){case"medium":t="Medium";break;case"hard":t="Hard";break;default:t="Easy"}return i.createElement("span",{className:a[n]},t)},s=t(6529),r=function(e){var n=e.solutionType,t=e.labels,a=e.companies,r=e.url;return i.createElement(i.Fragment,null,i.createElement(l,{type:n}),i.createElement("br",null),i.createElement("br",null),i.createElement(s.Z,{labels:t}),i.createElement("br",null),a&&a.length>0&&i.createElement(i.Fragment,null,"Companies:",i.createElement(s.Z,{labels:a}),i.createElement("br",null)),"URL: ",i.createElement("a",{href:r,target:"_blank",rel:"noopener noreferrer"},r),i.createElement("br",null),i.createElement("br",null))}},5892:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return u},default:function(){return m},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return h}});var i=t(7462),a=t(3366),l=(t(7294),t(3905)),s=t(5714),r=["components"],o={title:"146. LRU Cache (Medium)",tags:["Hash Table","Linked List","Design","Double Linked List","Medium"]},u=void 0,c={unversionedId:"146",id:"146",title:"146. LRU Cache (Medium)",description:"<SolutionDocHead",source:"@site/solutions/146.mdx",sourceDirName:".",slug:"/146",permalink:"/leetcode/solutions/146",tags:[{label:"Hash Table",permalink:"/leetcode/solutions/tags/hash-table"},{label:"Linked List",permalink:"/leetcode/solutions/tags/linked-list"},{label:"Design",permalink:"/leetcode/solutions/tags/design"},{label:"Double Linked List",permalink:"/leetcode/solutions/tags/double-linked-list"},{label:"Medium",permalink:"/leetcode/solutions/tags/medium"}],version:"current",lastUpdatedBy:"Gaurav Bharti",lastUpdatedAt:1651171487,formattedLastUpdatedAt:"4/29/2022",frontMatter:{title:"146. LRU Cache (Medium)",tags:["Hash Table","Linked List","Design","Double Linked List","Medium"]},sidebar:"solutions",previous:{title:"136. Single Number (Easy)",permalink:"/leetcode/solutions/136"},next:{title:"153. Find Minimum in Rotated Sorted Array (Medium)",permalink:"/leetcode/solutions/153"}},d={},h=[],p={toc:h};function m(e){var n=e.components,t=(0,a.Z)(e,r);return(0,l.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)(s.Z,{solutionType:"medium",labels:["Hash Table","Linked List","Design","Double Linked List"],url:"https://leetcode.com/problems/lru-cache/",mdxType:"SolutionDocHead"}),(0,l.kt)("p",null,"Design a data structure that follows the constraints of a ",(0,l.kt)("b",null,"Least Recently Used (LRU) cache"),"."),(0,l.kt)("p",null,"Implement the ",(0,l.kt)("inlineCode",{parentName:"p"},"LRUCache")," class:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"LRUCache(int capacity)")," Initialize the LRU cache with ",(0,l.kt)("b",null,"positive")," size ",(0,l.kt)("inlineCode",{parentName:"li"},"capacity"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"int get(int key)")," Return the value of the ",(0,l.kt)("inlineCode",{parentName:"li"},"key")," if the key exists, otherwise return ",(0,l.kt)("inlineCode",{parentName:"li"},"-1"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"void put(int key, int value)")," Update the value of the ",(0,l.kt)("inlineCode",{parentName:"li"},"key")," if the ",(0,l.kt)("inlineCode",{parentName:"li"},"key")," exists. Otherwise, add the ",(0,l.kt)("inlineCode",{parentName:"li"},"key-value")," pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.")),(0,l.kt)("p",null,"The functions ",(0,l.kt)("inlineCode",{parentName:"p"},"get")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"put")," must each run in ",(0,l.kt)("inlineCode",{parentName:"p"},"O(1)")," average time complexity."),(0,l.kt)("b",null,"Example 1:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'Input\n["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=solution.ts",title:"solution.ts"},"class LinkedListNode {\n  key: number;\n  val: number;\n  next: LinkedListNode;\n  prev: LinkedListNode;\n  constructor(key, val) {\n    this.key = key;\n    this.val = val;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\nclass DoublyLinkedList {\n  head: LinkedListNode;\n  tail: LinkedListNode;\n  length: number;\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  push(key: number, val: number) {\n    const newNode = new LinkedListNode(key, val);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      this.tail.next = newNode;\n      newNode.prev = this.tail;\n      this.tail = newNode;\n    }\n    this.length++;\n    return newNode;\n  }\n  remove(node: LinkedListNode) {\n    if (!node.next && !node.prev) {\n      // if only 1 node\n      this.head = null;\n      this.tail = null;\n    } else if (!node.next) {\n      // if node is tail\n      this.tail = node.prev;\n      this.tail.next = null;\n    } else if (!node.prev) {\n      // if node is head node\n      this.head = node.next;\n      this.head.prev = null;\n    } else {\n      // if node is in between\n      const prev = node.prev;\n      const next = node.next;\n      prev.next = next;\n      next.prev = prev;\n    }\n    this.length--;\n  }\n}\n\nclass LRUCache {\n  DLL: DoublyLinkedList;\n  map: Record<number, LinkedListNode>;\n  capacity: number;\n  constructor(capacity: number) {\n    this.DLL = new DoublyLinkedList();\n    this.map = {};\n    this.capacity = capacity;\n  }\n\n  get(key: number): number {\n    if (!this.map[key]) {\n      return -1;\n    }\n    const value = this.map[key].val;\n    this.DLL.remove(this.map[key]);\n    this.map[key] = this.DLL.push(key, value);\n    return value;\n  }\n\n  put(key: number, value: number): void {\n    if (this.map[key]) this.DLL.remove(this.map[key]);\n    this.map[key] = this.DLL.push(key, value);\n    if (this.DLL.length > this.capacity) {\n      const currKey = this.DLL.head.key;\n      delete this.map[currKey];\n      this.DLL.remove(this.DLL.head);\n    }\n  }\n}\n")))}m.isMDXComponent=!0}}]);