"use strict";(self.webpackChunkleetcode=self.webpackChunkleetcode||[]).push([[4434],{5892:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return r},default:function(){return k},frontMatter:function(){return u},metadata:function(){return d},toc:function(){return h}});var i=t(7462),a=t(3366),l=(t(7294),t(3905)),s=t(5714),o=["components"],u={title:"146. LRU Cache (Medium)",tags:["Hash Table","Linked List","Design","Double Linked List","Medium"]},r=void 0,d={unversionedId:"146",id:"146",title:"146. LRU Cache (Medium)",description:"<SolutionDocHead",source:"@site/solutions/146.mdx",sourceDirName:".",slug:"/146",permalink:"/leetcode/solutions/146",tags:[{label:"Hash Table",permalink:"/leetcode/solutions/tags/hash-table"},{label:"Linked List",permalink:"/leetcode/solutions/tags/linked-list"},{label:"Design",permalink:"/leetcode/solutions/tags/design"},{label:"Double Linked List",permalink:"/leetcode/solutions/tags/double-linked-list"},{label:"Medium",permalink:"/leetcode/solutions/tags/medium"}],version:"current",lastUpdatedBy:"Gaurav Bharti",lastUpdatedAt:1651171487,formattedLastUpdatedAt:"4/29/2022",frontMatter:{title:"146. LRU Cache (Medium)",tags:["Hash Table","Linked List","Design","Double Linked List","Medium"]},sidebar:"solutions",previous:{title:"136. Single Number (Easy)",permalink:"/leetcode/solutions/136"},next:{title:"153. Find Minimum in Rotated Sorted Array (Medium)",permalink:"/leetcode/solutions/153"}},c={},h=[],p={toc:h};function k(e){var n=e.components,t=(0,a.Z)(e,o);return(0,l.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)(s.Z,{solutionType:"medium",labels:["Hash Table","Linked List","Design","Double Linked List"],url:"https://leetcode.com/problems/lru-cache/",mdxType:"SolutionDocHead"}),(0,l.kt)("p",null,"Design a data structure that follows the constraints of a ",(0,l.kt)("b",null,"Least Recently Used (LRU) cache"),"."),(0,l.kt)("p",null,"Implement the ",(0,l.kt)("inlineCode",{parentName:"p"},"LRUCache")," class:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"LRUCache(int capacity)")," Initialize the LRU cache with ",(0,l.kt)("b",null,"positive")," size ",(0,l.kt)("inlineCode",{parentName:"li"},"capacity"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"int get(int key)")," Return the value of the ",(0,l.kt)("inlineCode",{parentName:"li"},"key")," if the key exists, otherwise return ",(0,l.kt)("inlineCode",{parentName:"li"},"-1"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"void put(int key, int value)")," Update the value of the ",(0,l.kt)("inlineCode",{parentName:"li"},"key")," if the ",(0,l.kt)("inlineCode",{parentName:"li"},"key")," exists. Otherwise, add the ",(0,l.kt)("inlineCode",{parentName:"li"},"key-value")," pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.")),(0,l.kt)("p",null,"The functions ",(0,l.kt)("inlineCode",{parentName:"p"},"get")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"put")," must each run in ",(0,l.kt)("inlineCode",{parentName:"p"},"O(1)")," average time complexity."),(0,l.kt)("b",null,"Example 1:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'Input\n["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=solution.ts",title:"solution.ts"},"class LinkedListNode {\n  key: number;\n  val: number;\n  next: LinkedListNode;\n  prev: LinkedListNode;\n  constructor(key, val) {\n    this.key = key;\n    this.val = val;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\nclass DoublyLinkedList {\n  head: LinkedListNode;\n  tail: LinkedListNode;\n  length: number;\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  push(key: number, val: number) {\n    const newNode = new LinkedListNode(key, val);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      this.tail.next = newNode;\n      newNode.prev = this.tail;\n      this.tail = newNode;\n    }\n    this.length++;\n    return newNode;\n  }\n  remove(node: LinkedListNode) {\n    if (!node.next && !node.prev) {\n      // if only 1 node\n      this.head = null;\n      this.tail = null;\n    } else if (!node.next) {\n      // if node is tail\n      this.tail = node.prev;\n      this.tail.next = null;\n    } else if (!node.prev) {\n      // if node is head node\n      this.head = node.next;\n      this.head.prev = null;\n    } else {\n      // if node is in between\n      const prev = node.prev;\n      const next = node.next;\n      prev.next = next;\n      next.prev = prev;\n    }\n    this.length--;\n  }\n}\n\nclass LRUCache {\n  DLL: DoublyLinkedList;\n  map: Record<number, LinkedListNode>;\n  capacity: number;\n  constructor(capacity: number) {\n    this.DLL = new DoublyLinkedList();\n    this.map = {};\n    this.capacity = capacity;\n  }\n\n  get(key: number): number {\n    if (!this.map[key]) {\n      return -1;\n    }\n    const value = this.map[key].val;\n    this.DLL.remove(this.map[key]);\n    this.map[key] = this.DLL.push(key, value);\n    return value;\n  }\n\n  put(key: number, value: number): void {\n    if (this.map[key]) this.DLL.remove(this.map[key]);\n    this.map[key] = this.DLL.push(key, value);\n    if (this.DLL.length > this.capacity) {\n      const currKey = this.DLL.head.key;\n      delete this.map[currKey];\n      this.DLL.remove(this.DLL.head);\n    }\n  }\n}\n")))}k.isMDXComponent=!0}}]);