"use strict";(self.webpackChunkleetcode=self.webpackChunkleetcode||[]).push([[7137],{2699:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return d},default:function(){return T},frontMatter:function(){return u},metadata:function(){return c},toc:function(){return m}});var r=n(7462),a=n(3366),l=(n(7294),n(3905)),o=n.p+"assets/images/image-2befa09ea7ae2de0200ff8009d2a4141.png",i=n(5714),s=["components"],u={title:"173. Binary Search Tree Iterator (Medium)",tags:["Stack","Tree","Design","Binary Search Tree","Binary Tree","Iterator","Medium"]},d=void 0,c={unversionedId:"173",id:"173",title:"173. Binary Search Tree Iterator (Medium)",description:"<SolutionDocHead",source:"@site/solutions/173.mdx",sourceDirName:".",slug:"/173",permalink:"/leetcode/solutions/173",tags:[{label:"Stack",permalink:"/leetcode/solutions/tags/stack"},{label:"Tree",permalink:"/leetcode/solutions/tags/tree"},{label:"Design",permalink:"/leetcode/solutions/tags/design"},{label:"Binary Search Tree",permalink:"/leetcode/solutions/tags/binary-search-tree"},{label:"Binary Tree",permalink:"/leetcode/solutions/tags/binary-tree"},{label:"Iterator",permalink:"/leetcode/solutions/tags/iterator"},{label:"Medium",permalink:"/leetcode/solutions/tags/medium"}],version:"current",lastUpdatedBy:"Gaurav Bharti",lastUpdatedAt:1651589992,formattedLastUpdatedAt:"5/3/2022",frontMatter:{title:"173. Binary Search Tree Iterator (Medium)",tags:["Stack","Tree","Design","Binary Search Tree","Binary Tree","Iterator","Medium"]},sidebar:"solutions",previous:{title:"167. Two Sum II - Input Array Is Sorted (Medium)",permalink:"/leetcode/solutions/167"},next:{title:"187. Repeated DNA Sequences (Medium)",permalink:"/leetcode/solutions/187"}},h={},m=[],p={toc:m};function T(e){var t=e.components,n=(0,a.Z)(e,s);return(0,l.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)(i.Z,{solutionType:"medium",labels:["Stack","Tree","Design","Binary Search Tree","Binary Tree","Iterator"],url:"https://leetcode.com/problems/binary-search-tree-iterator/",mdxType:"SolutionDocHead"}),(0,l.kt)("p",null,"Implement the ",(0,l.kt)("inlineCode",{parentName:"p"},"BSTIterator")," class that represents an iterator over the in-order traversal of a binary search tree (BST):"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"BSTIterator(TreeNode root)")," Initializes an object of the ",(0,l.kt)("inlineCode",{parentName:"li"},"BSTIterator")," class. The ",(0,l.kt)("inlineCode",{parentName:"li"},"root")," of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"boolean hasNext()")," Returns ",(0,l.kt)("inlineCode",{parentName:"li"},"true")," if there exists a number in the traversal to the right of the pointer, otherwise returns false."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"int next()")," Moves the pointer to the right, then returns the number at the pointer.")),(0,l.kt)("p",null,"Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST."),(0,l.kt)("p",null,"You may assume that ",(0,l.kt)("inlineCode",{parentName:"p"},"next()")," calls will always be valid. That is, there will be at least a next number in the in-order traversal when ",(0,l.kt)("inlineCode",{parentName:"p"},"next()")," is called."),(0,l.kt)("b",null,"Example 1:"),(0,l.kt)("br",null),(0,l.kt)("img",{src:o}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'Input\n["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\nOutput\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\nExplanation\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=TreeNode.ts",title:"TreeNode.ts"},"class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=solution.ts",title:"solution.ts"},"class BSTIterator {\n  root: TreeNode | null;\n  stack: TreeNode[];\n  constructor(root: TreeNode | null) {\n    this.root = root;\n    this.stack = [];\n  }\n\n  next(): number {\n    while (this.root) {\n      this.stack.push(this.root);\n      this.root = this.root.left;\n    }\n    const res = this.stack.pop();\n    this.root = res.right;\n    return res.val;\n  }\n\n  hasNext(): boolean {\n    if (this.root || this.stack.length) {\n      return true;\n    }\n    return false;\n  }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n")))}T.isMDXComponent=!0}}]);