"use strict";(self.webpackChunkleetcode=self.webpackChunkleetcode||[]).push([[770],{6529:function(e,n,t){var r=t(7294),a=t(1285),s=(0,t(1120).Z)((function(e){return{root:{display:"flex",flexWrap:"wrap","& > *":{margin:e.spacing(.5)}}}}));n.Z=function(e){var n=s(),t=e.labels;return r.createElement("div",{className:n.root},t.map((function(e,n){return r.createElement(a.Z,{label:e,key:n+"-"+e})})))}},5714:function(e,n,t){t.d(n,{Z:function(){return i}});var r=t(7294),a={medium:"medium_AtL5",easy:"easy_Arst",hard:"hard_vnPO"},s=function(e){var n=e.type,t="";switch(n){case"medium":t="Medium";break;case"hard":t="Hard";break;default:t="Easy"}return r.createElement("span",{className:a[n]},t)},o=t(6529),i=function(e){var n=e.solutionType,t=e.labels,a=e.companies,i=e.url;return r.createElement(r.Fragment,null,r.createElement(s,{type:n}),r.createElement("br",null),r.createElement("br",null),r.createElement(o.Z,{labels:t}),r.createElement("br",null),a&&a.length>0&&r.createElement(r.Fragment,null,"Companies:",r.createElement(o.Z,{labels:a}),r.createElement("br",null)),"URL: ",r.createElement("a",{href:i,target:"_blank",rel:"noopener noreferrer"},i),r.createElement("br",null),r.createElement("br",null))}},3722:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return u},default:function(){return h},frontMatter:function(){return l},metadata:function(){return m},toc:function(){return p}});var r=t(7462),a=t(3366),s=(t(7294),t(3905)),o=t(5714),i=["components"],l={title:"15. 3Sum (Medium)",tags:["Array","Two Pointers","Sorting"]},u=void 0,m={unversionedId:"15",id:"15",title:"15. 3Sum (Medium)",description:"<SolutionDocHead",source:"@site/solutions/15.mdx",sourceDirName:".",slug:"/15",permalink:"/solutions/15",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Two Pointers",permalink:"/solutions/tags/two-pointers"},{label:"Sorting",permalink:"/solutions/tags/sorting"}],version:"current",lastUpdatedBy:"Gaurav Bharti",lastUpdatedAt:1650482437,formattedLastUpdatedAt:"4/21/2022",frontMatter:{title:"15. 3Sum (Medium)",tags:["Array","Two Pointers","Sorting"]},sidebar:"solutions",previous:{title:"11. Container With Most Water (Medium)",permalink:"/solutions/11"},next:{title:"26. Remove Duplicates from Sorted Array (Easy)",permalink:"/solutions/26"}},c={},p=[],d={toc:p};function h(e){var n=e.components,t=(0,a.Z)(e,i);return(0,s.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)(o.Z,{solutionType:"medium",labels:["Array","Two Pointers","Sorting"],url:"https://leetcode.com/problems/3sum/",mdxType:"SolutionDocHead"}),(0,s.kt)("p",null,"Given an integer array nums, return all the triplets ",(0,s.kt)("inlineCode",{parentName:"p"},"[nums[i], nums[j], nums[k]]")," such that ",(0,s.kt)("inlineCode",{parentName:"p"},"i != j"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"i != k"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"j != k"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"nums[i] + nums[j] + nums[k] == 0"),"."),(0,s.kt)("p",null,"Notice that the solution set must not contain duplicate triplets."),(0,s.kt)("b",null,"Example 1:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\n")),(0,s.kt)("b",null,"Example 2:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: nums = []\nOutput: []\n")),(0,s.kt)("b",null,"Example 3:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: nums = [0]\nOutput: []\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=solution.ts",title:"solution.ts"},"function threeSum(nums: number[]): number[][] {\n  const results = [];\n\n  // obviously irrelevant if we don't have at least 3 numbers to play with!\n  if (nums.length < 3) return results;\n\n  // having the numbers in ascending order will make this problem much easier.\n  // also, knowing the overall problem  will take at least O(N^2) time, we can\n  // afford the O(NlogN) sort operation\n  nums = nums.sort((a, b) => a - b);\n\n  // if the question asks us for a custom target, we can control it here\n  let target = 0;\n\n  for (let i = 0; i < nums.length - 2; i++) {\n    // `i` represents the \"left\" most number in our sorted set.\n    // once this number hits 0, there's no need to go further since\n    // positive numbers cannot sum to a negative number\n    if (nums[i] > target) break;\n\n    // we don't want repeats, so skip numbers we've already seen\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n\n    // `j` represents the \"middle\" element between `i` and `k`.\n    // we will increment this up through the array while `i` and `k`\n    // are anchored to their positions. we will decrement `k` for\n    // for each pass through the array, and finally increment `i`\n    // once `j` and `k` meet.\n    let j = i + 1;\n\n    // `k` represents the \"right\" most element\n    let k = nums.length - 1;\n\n    // to summarize our setup, we have `i` that starts at the beginning,\n    // `k` that starts at the end, and `j` that races in between the two.\n    //\n    // note that `i` is controlled by our outer for-loop and will move the slowest.\n    // in the meantime, `j` and `k` will take turns inching towards each other depending\n    // on some logic we'll set up below. once they collide, `i` will be incremented up\n    // and we'll repeat the process.\n\n    while (j < k) {\n      let sum = nums[i] + nums[j] + nums[k];\n\n      // if we find the target sum, increment `j` and decrement `k` for\n      // other potential combos where `i` is the anchor\n      if (sum === target) {\n        // store the valid threesum\n        results.push([nums[i], nums[j], nums[k]]);\n\n        // this is important! we need to continue to increment `j` and decrement `k`\n        // as long as those values are duplicated. in other words, we wanna skip values\n        // we've already seen. otherwise, an input array of [-2,0,0,2,2] would result in\n        // [[-2,0,2], [-2,0,2]].\n        //\n        // (i'm not a fan of this part because we're doing a while loop as we're\n        // already inside of another while loop...)\n        while (nums[j] === nums[j + 1]) j++;\n        while (nums[k] === nums[k - 1]) k--;\n\n        // finally, we need to actually move `j` forward and `k` backward to the\n        // next unique elements. the previous while loops will not handle this.\n        j++;\n        k--;\n\n        // if the sum is too small, increment `j` to get closer to the target\n      } else if (sum < target) {\n        j++;\n\n        // if the sum is too large, decrement `k` to get closer to the target\n      } else {\n        // (sum > target)\n        k--;\n      }\n    }\n  }\n\n  return results;\n}\n")))}h.isMDXComponent=!0}}]);