"use strict";(self.webpackChunkleetcode=self.webpackChunkleetcode||[]).push([[8279],{6529:function(e,t,n){var r=n(7294),a=n(1285),i=(0,n(1120).Z)((function(e){return{root:{display:"flex",flexWrap:"wrap","& > *":{margin:e.spacing(.5)}}}}));t.Z=function(e){var t=i(),n=e.labels;return r.createElement("div",{className:t.root},n.map((function(e,t){return r.createElement(a.Z,{label:e,key:t+"-"+e})})))}},5714:function(e,t,n){n.d(t,{Z:function(){return l}});var r=n(7294),a={medium:"medium_AtL5",easy:"easy_Arst",hard:"hard_vnPO"},i=function(e){var t=e.type,n="";switch(t){case"medium":n="Medium";break;case"hard":n="Hard";break;default:n="Easy"}return r.createElement("span",{className:a[t]},n)},s=n(6529),l=function(e){var t=e.solutionType,n=e.labels,a=e.companies,l=e.url;return r.createElement(r.Fragment,null,r.createElement(i,{type:t}),r.createElement("br",null),r.createElement("br",null),r.createElement(s.Z,{labels:n}),r.createElement("br",null),a&&a.length>0&&r.createElement(r.Fragment,null,"Companies:",r.createElement(s.Z,{labels:a}),r.createElement("br",null)),"URL: ",r.createElement("a",{href:l,target:"_blank",rel:"noopener noreferrer"},l),r.createElement("br",null),r.createElement("br",null))}},9299:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return m}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),s=n(5714),l=["components"],o={title:"10. Regular Expression Matching (Hard)",tags:["String","Dynamic Programming","Recursion","Hard"]},c=void 0,u={unversionedId:"10",id:"10",title:"10. Regular Expression Matching (Hard)",description:"<SolutionDocHead",source:"@site/solutions/10.mdx",sourceDirName:".",slug:"/10",permalink:"/leetcode/solutions/10",tags:[{label:"String",permalink:"/leetcode/solutions/tags/string"},{label:"Dynamic Programming",permalink:"/leetcode/solutions/tags/dynamic-programming"},{label:"Recursion",permalink:"/leetcode/solutions/tags/recursion"},{label:"Hard",permalink:"/leetcode/solutions/tags/hard"}],version:"current",lastUpdatedBy:"Gaurav Bharti",lastUpdatedAt:1650915156,formattedLastUpdatedAt:"4/26/2022",frontMatter:{title:"10. Regular Expression Matching (Hard)",tags:["String","Dynamic Programming","Recursion","Hard"]},sidebar:"solutions",previous:{title:"6. Zigzag Conversion (Medium)",permalink:"/leetcode/solutions/6"},next:{title:"11. Container With Most Water (Medium)",permalink:"/leetcode/solutions/11"}},p={},m=[],h={toc:m};function d(e){var t=e.components,n=(0,a.Z)(e,l);return(0,i.kt)("wrapper",(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(s.Z,{solutionType:"hard",labels:["String","Dynamic Programming","Recursion"],url:"https://leetcode.com/problems/regular-expression-matching/",mdxType:"SolutionDocHead"}),(0,i.kt)("p",null,"Given an input string ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," and a pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"p"),", implement regular expression matching with support for ",(0,i.kt)("inlineCode",{parentName:"p"},"'.'")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"'*'")," where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'.'")," Matches any single character.\u200b\u200b\u200b\u200b"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'*'")," Matches zero or more of the preceding element.")),(0,i.kt)("p",null,"The matching should cover the ",(0,i.kt)("b",null,"entire")," input string (not partial)."),(0,i.kt)("b",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: s = "aa", p = "a"\nOutput: false\nExplanation: "a" does not match the entire string "aa".\n')),(0,i.kt)("b",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n")),(0,i.kt)("b",null,"Example 3:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: s = "ab", p = "._"\nOutput: true\nExplanation: "._" means "zero or more (\\*) of any character (.)".\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=solution.ts",title:"solution.ts"},'function isMatch(s: string, p: string): boolean {\n  if (!p) {\n    // returns true when string and pattern are empty\n    // returns false when string contains chars with empty pattern\n    return !s;\n  }\n  // check if current char of the string and pattern match when the string has chars\n  const hasFirstCharMatch = Boolean(s) && (p[0] === "." || p[0] === s[0]);\n\n  // track when the next character * is next in line in pattern\n  if (p[1] === "*") {\n    // if next pattern match (after *) is fine with current string, then proceed with it (s, p+2).  That\'s because the current pattern may be skipped.\n    // otherwise check hasFirstCharMatch. That\'s because if we want to proceed with the current pattern, we must be sure that the current pattern char matches the char\n    // If hasFirstCharMatch is true, then do the recursion with next char and current pattern (s+1, p).  That\'s because current char matches the pattern char.\n    return (\n      isMatch(s, p.slice(2)) || (hasFirstCharMatch && isMatch(s.slice(1), p))\n    );\n  }\n  // now we know for sure that we need to do 2 simple actions\n  // check the current pattern and string chars\n  // if so, then can proceed with next string and pattern chars (s+1, p+1)\n  return hasFirstCharMatch ? isMatch(s.slice(1), p.slice(1)) : false;\n}\n')))}d.isMDXComponent=!0}}]);