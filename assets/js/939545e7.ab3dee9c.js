"use strict";(self.webpackChunkleetcode=self.webpackChunkleetcode||[]).push([[8279],{9299:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return c},metadata:function(){return p},toc:function(){return h}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),s=n(5714),o=["components"],c={title:"10. Regular Expression Matching (Hard)",tags:["String","Dynamic Programming","Recursion"]},l=void 0,p={unversionedId:"10",id:"10",title:"10. Regular Expression Matching (Hard)",description:"<SolutionDocHead",source:"@site/solutions/10.mdx",sourceDirName:".",slug:"/10",permalink:"/leetcode/solutions/10",tags:[{label:"String",permalink:"/leetcode/solutions/tags/string"},{label:"Dynamic Programming",permalink:"/leetcode/solutions/tags/dynamic-programming"},{label:"Recursion",permalink:"/leetcode/solutions/tags/recursion"}],version:"current",lastUpdatedBy:"Gaurav Bharti",lastUpdatedAt:1650890825,formattedLastUpdatedAt:"4/25/2022",frontMatter:{title:"10. Regular Expression Matching (Hard)",tags:["String","Dynamic Programming","Recursion"]},sidebar:"solutions",previous:{title:"6. Zigzag Conversion (Medium)",permalink:"/leetcode/solutions/6"},next:{title:"11. Container With Most Water (Medium)",permalink:"/leetcode/solutions/11"}},u={},h=[],m={toc:h};function d(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(s.Z,{solutionType:"hard",labels:["String","Dynamic Programming","Recursion"],url:"https://leetcode.com/problems/regular-expression-matching/",mdxType:"SolutionDocHead"}),(0,i.kt)("p",null,"Given an input string ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," and a pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"p"),", implement regular expression matching with support for ",(0,i.kt)("inlineCode",{parentName:"p"},"'.'")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"'*'")," where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'.'")," Matches any single character.\u200b\u200b\u200b\u200b"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'*'")," Matches zero or more of the preceding element.")),(0,i.kt)("p",null,"The matching should cover the ",(0,i.kt)("b",null,"entire")," input string (not partial)."),(0,i.kt)("b",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: s = "aa", p = "a"\nOutput: false\nExplanation: "a" does not match the entire string "aa".\n')),(0,i.kt)("b",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n")),(0,i.kt)("b",null,"Example 3:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: s = "ab", p = "._"\nOutput: true\nExplanation: "._" means "zero or more (\\*) of any character (.)".\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=solution.ts",title:"solution.ts"},'function isMatch(s: string, p: string): boolean {\n  if (!p) {\n    // returns true when string and pattern are empty\n    // returns false when string contains chars with empty pattern\n    return !s;\n  }\n  // check if current char of the string and pattern match when the string has chars\n  const hasFirstCharMatch = Boolean(s) && (p[0] === "." || p[0] === s[0]);\n\n  // track when the next character * is next in line in pattern\n  if (p[1] === "*") {\n    // if next pattern match (after *) is fine with current string, then proceed with it (s, p+2).  That\'s because the current pattern may be skipped.\n    // otherwise check hasFirstCharMatch. That\'s because if we want to proceed with the current pattern, we must be sure that the current pattern char matches the char\n    // If hasFirstCharMatch is true, then do the recursion with next char and current pattern (s+1, p).  That\'s because current char matches the pattern char.\n    return (\n      isMatch(s, p.slice(2)) || (hasFirstCharMatch && isMatch(s.slice(1), p))\n    );\n  }\n  // now we know for sure that we need to do 2 simple actions\n  // check the current pattern and string chars\n  // if so, then can proceed with next string and pattern chars (s+1, p+1)\n  return hasFirstCharMatch ? isMatch(s.slice(1), p.slice(1)) : false;\n}\n')))}d.isMDXComponent=!0}}]);